\chapter{The \WoTLong{}}
\label{wot}
\cquote{Any sufficiently advanced technology is indistinguishable from magic}{Arthur C. Clarke}
\minitoc

\begin{figure}
\centering 
 \imgLine{wot/wot-architecture-new}
\caption{The four layers of the Web of Things architecture: Accessibility, Findability, Sharing, Composition. Applications can be built on top of each layer, but as we go up the layers they become more accessible to a broader community of developers and users. The figure provides an overview of the deliverables of this thesis. On the left-side are the architectural building-blocks. On the right-side the applications and prototypes.}
\label{fig:wotArchi}
\end{figure}
In this chapter, we present the \WoTA{}. We describe the four layers it is based on: the \devLayer{}, \findLayer{}, \shareLayer{} and \compoLayer{} as shown in \figRef{wotArchi}.

The overall goal of this architecture is to facilitate the integration of \sts{} with existing services on the Web and to facilitate the creation of Web applications using \sts{}. In particular, we formulate the following general requirements~\cite{Guinard2010-Search,Guinard2011} we would like for our architecture to fulfill:
 \begin{enumerate}
 \item It should \important{lower the entry barrier for developers} and foster rapid prototyping. This allows a wider range of developers, tech-savvy users (technologically skilled people) or researchers to develop on top of \sts{} and contributes to fostering third party (public) innovation using \sts{}.
 
  \item It should \important{offer direct access for users}. Users should be able to access and use \sts{} without the need for installing additional software. From a Web browser (or an HTTP library in the case of a software client) they should further have means to directly extract, save and share \sts{} data and services. This ensures the usability of the architecture and minimizes the entry barriers for users.
 
 \item It should offer a \important{lightweight} access to \sts{} data. This enables creating applications in which real-world data are directly consumed by \important{resource-constrained devices} such as mobile phones or wireless sensor nodes without requiring dedicated software on these devices.
\end{enumerate} 

Unlike traditional layered architectures such as the OSI (Open Systems Interconnection) model~\cite{Day1983}, the layers in the presented \WoTA{} are not strictly defined and do not literally hide the previous layers. Rather, the architecture should be seen as an ecosystem of different services that ease, step by step, the creation of applications using \sts{}. The architecture proposes services that address each layer required to consider \sts{} as first-class citizen of the Web. However, applications can be built on top of the services offered by the implementation of each layer or on top of a combination of them depending on the requirements of a particular use-case.

As illustrated on \figRef{wotArchi} the development of applications using \sts{} on top of their native operating systems, protocols and libraries still requires specific skills and is, for the greater part, only accessible to embedded systems experts~\cite{Mottola2011}. The goal of each layer of the \WoTA{} is first to bring this development closer to Web developers and technically skilled hobbyists~\cite{Hartmann2008}. Then, it brings the usage and development of Internet of Things applications closer to end-users, enabling them to create simple applications tailored to their needs.

In this chapter, we describe each layer. Focusing first on the architecture of the components in these layers, we then look at the services and APIs they offer and propose implementations of these services. The proposed components are evaluated in a generic way in this chapter. These evaluations are complemented by \chapterRef{wsn} and \chapterRef{autoid}, where we apply the architecture to two specific domains: Wireless Sensor Networks and RFID tagged-objects and evaluate it within these domains.


% These are the actual sections of this chapter...
\input{chapters/webofthings/deviceAccessibilityLayer}
\input{chapters/webofthings/findabilityLayer}
\input{chapters/webofthings/sharingLayer}
\input{chapters/webofthings/compositionLayer}
\input{chapters/webofthings/alternativeArchitectures}


\section{Related Work}\label{relatedWork}
In this section we discuss previous research related to the \WoTA{}. It is structured according to the layers of \WoTA{} beginning with work related to creating a global network of \sts{} (\devLayer{}) and ending with ways of composing the services of \sts{} in an easy and accessible manner (\compoLayer{}).

\subsection{\devLayer{}}
Linking the Web and physical objects is an attractive idea that has already been in the mind of researchers for years. Early approaches started by attaching physical tokens (such as barcodes) to objects to direct the user to pages on the Web containing information about the objects~\cite{Want1999}. These pages were first served by static Web Servers on mainframes, then by early gateway system that enabled low-power devices to be part of wider networks~\cite{Schramm2004}. The Cooltown project pioneered this area of the physical Web by associating pages and URIs to people, places and things~\cite{Kindberg2002} and implementing scenarios where this information could by physically discovered by scanning infrared tags in the environment. Similarly, the SPREAD physical/spatial computing model~\cite{Couderc2003} consisted in spreading, with the help of wireless technologies, information that could then be retrieved by mobile users, pointing them to contextually related Web resources. The key idea of these works was to provide a virtual counterpart of the physical objects on the Web. URIs to Web pages were scanned by users e.g., using mobile devices and directed them to online representations of real things (e.g., containing status of appliances on HTML pages or user manuals).

A number of projects proposed solutions to expose the functionality of \sts{} through APIs in order to build applications upon real-world devices. Among them, JINI, UPnP, DNLA, etc. The advent of WS-* Web Services (SOAP, WSDL, etc.) led to a number of works towards deploying them on embedded devices and sensor networks~\cite{Priyantha2008,DeSouza2008,Marin-Perianu2007}. DPWS is a subset of the WS-* standards that allows minimal interaction with web services running on embedded devices. DPWS specifies a protocol for seamless interaction with the services offered by different embedded devices. DPWS is aligned (and for the most part compatible) with WS-* technologies. The various specifications DPWS include support for messaging, service discovery, service description, and eventing for resource-constrained devices.

We joined this research and proposed a middleware that bridges the gap between DPWS embedded-devices and enterprise applications, taking care of cross-cutting concerns such as search, service composition, dynamic provisioning of services and data storage~\cite{Spiess2009,DeSouza2008}. However, in \sectRef{alternatives} we discussed the shortcomings of the approach in the case of the \WoT{}.

Several systems (or middleware) for integration of \sts{} with the Web have been proposed such as SenseWeb~\cite{Grosky2007,Luo2008}, the Global Sensor Network (GSN)~\cite{Aberer2007}, Pachube~\citeweb{pachube}, ThingSpeak~\citeweb{thingspeak}, Sen.se~\citeweb{sense}, ThingWorx~\citeweb{thingworx} or Sensor.Network~\cite{Gupta2010}. These offer platforms for people to share their sensory readings using Web services to transmit data onto a central server and thus cover several layers of the \WoTA{}. However, these approaches are focused on building central repositories on top of which services can be built. 

The idea to push the Web and the Internet as close as possible to \sts{} was explored early on in the Internet0 project~\cite{Gershenfeld2006}. Gershenfeld and Cohen understood early on the importance of having a single protocol for \sts{} and proposed adapting Internet protocols to embedded devices. 

With advances in computing technology, tiny Web servers can be embedded in most devices~\cite{Dunkels2003,Hui2008,Duquennoy2009a} and thus not only Internet but also Web technologies can be pushed to \sts{}. Hence, in the \devLayer{}, we propose using the Web and its technologies as the integration backbone of \sts{}. We build upon works towards the Web integration of wireless sensor networks such as~\cite{Luckenbach2005,Drytkiewicz2004-pREST,Dickerson2008} and extend them by systematically applying the constrains of RESTful architectures to \sts{} and discussing the concept of \sgs{} to integrate non-IP enabled devices~\cite{Guinard2011b}. Furthermore, we complement this work by proposing the three other layers that streamline the development of applications using \sts{} to what can be done today with Web 2.0 mashups. 

\subsection{\findLayer{}}
Search has become such a central commodity that it is hard to imagine the Web without search engines. The findability of information~\cite{Morville2005}, people and places has become a central concern of most information architectures~\cite{Morville2006}. However, while search in the Web of documents is already significantly advanced, searching the real-world remains one of the biggest open challenges for the \WoTLong{} to materialize. 

When considering the \WoTLong{} beyond micro use-cases such as home or factory automation, focusing on macro use-cases where billions of things are available and connected to the Web, then discovery simply by browsing HTML pages with hyperlinks becomes difficult. Searching for things is significantly more complicated than searching for documents~\cite{Romer2010}, as things are tightly bound to contextual information such as location, are often moving from one context to another and their HTML representations are less keywords-rich than traditional Web pages. 

As a consequence, several researchers have been looking at specific ways of describing \sts{} and domain-specific standards have been proposed: SensorML~\cite{Botts2007} is a standard XML language that can be used to describe sensor network applications and devices. Similarly, the Extended Environments Markup Language (EEML)~\citeweb{eeml} is a language for describing sensor data in digitally enhanced environments.

Not specific to Wireless Sensor Networks and thus closer to the concerns of this thesis, DPWS~\cite{Jammes2005-DPWS} proposes a \newterm{device metadata language}~\citeweb{dpws} which offers a semantic description of what a real-world device is, by what company it was produced and what it has to offer in terms of functionality. DPWS metadata is often embedded in a WSDL (Webservice Description Language) file which in turns contains the interface description or API of the offered WS-* Webservices. Based on DPWS we proposed the SOCRADES Lookup and Search Infrastructure~\cite{Guinard2009b}.

The metadata offered by these languages is the basis of our proposed \stm{} model. However, these formats are not well supported and understood on the Web and for some parts overlap what HTTP already has to offer. As a consequence, they do not leverage the search infrastructure already in place on the Web (e.g., existing search engines). 

Closer to Web languages, researchers have been proposing the use of domain-specific ontologies to support semi-automated mashups of \sts{}~\cite{Vermeulen2007a,Katasonov2010}. Vermeulen et al. used this approach to implement mashups of tagged physical objects with services on the Web~\cite{Vermeulen2007}. While the expressive power of these approaches is significant so is their complexity. Our goal is to enable users to search the real-world and machines to understand the basics of \sts{} (e.g., in order to generate building-blocks of mashups). As a consequence we would like to consider descriptions that can be implemented in a lightweight manner with a constrained but sufficient descriptive power so that they can be understood by a vast number of existing infrastructure services. 

SA-REST~\cite{Lathem2007} proposes a lightweight alternative language that can be used to describe RESTful services sharing similarities to what the WSDL language can describe for WS-* services. This is also the proposal of the WADL (Web Applications Description Language)~\cite{Hadley2006} or of some extensions in the WSDL 2.0 language. However, SA-REST goes beyond these languages as it proposes to also support the composition of these services in semi-automatic mashups~\cite{Sheth2007}. Unfortunately, languages like SA-REST are not widely understood on the Web, for instance they are not processed by search engines. The importance of relying on mechanisms that can be well-understood by search engines for a realistic deployment of a service lookup service was discussed by Song et al.~\cite{Song2007}. 

Kopecky et al. propose to make descriptions of RESTful Web services directly embedded in HTML representations~\cite{Kopecky2008}. They propose the hRESTs microformat. Note that it is sometimes criticized by the Web community because most of the data the hRESTs microformat encapsulate can also be retrieved by crawling Web architectures that respect the REST constraints (and in particular the \important{connecteness} constraint). However, when deploying services directly on \sts{} (without \sgs{}) this format can be interesting as it avoids the great number of HTTP calls required by crawlers. Researchers such as Alarcon et al. discuss ways and languages to gather more valuable information when crawling RESTful services~\cite{Alarcon2010}.

Our approach is to propose the \stm{} model inspired by these description languages but we focus on a small set of properties that are sufficient to allow the findability of \sts{} and their integration into tools such as \pMashups{} editors. We further implement the model using a set of standard microformats as these are well supported and broadly understood by search engines. Yet, relying on existing search engines does not fully leverage \sts{} and does not really take into account their specific requirements such as mobility or their strong ties with physical locations. As a consequence a body of research is related to real-time search engines for the Internet and the \WoTLong{}.

As explained in the previous section, several platforms such as SenseWeb~\cite{Grosky2007,Luo2008}, Pachube or Sensor.Network~\cite{Gupta2010} were proposed. Building on top of Pachube, Kamilaris et al. propose \quote{bridging the Mobile Web and the \WoT{} in Urban Environments}~\cite{Kamilaris2010} and offer a mobile search engine using location information to retrieve nearby data services. Similarly, we explored using the concept of proximity to dynamically search for services offered by \sts{}~\cite{Gellersen2009}. However, these approaches are based on a centralized data lookup infrastructure and do not fully leverage the distributed nature of \sts{}.

In the world of business services, a crucial challenge for SOA developers and process designers is to find adequate services for solving a particular task~\cite{Crasso2008}. Discovering enterprise services often implies manually querying a number of registries, such as Universal Description and Discovery and Integration (UDDI) registries, and the results depend largely on the quality of the data within that registry. While such an approach is adequate for a rarely changing set of large-scale services, the same is insufficient for the requirements of the service offered by \sts{}. Registering a service with one or more UDDIs is rather complex (which is also why UDDIs are rarely used in practice), and does not comply with the usage minimization of the devices' limited resources. Furthermore extensive description information is necessary~\cite{Monson-Haefel2003}, while the \sts{} can only report basic information about themselves and the services they host. Trying to reduce the complexity of registration and discovery, different research directions have been followed in order to provide alternatives or extensions of the UDDI standard~\cite{Crasso2008,Song2007}. However, also these do not take into account the particular requirements of real-world services.  

R\"{o}mer et al. survey search engines for the real-world~\cite{Romer2010} and present their own engine in~\cite{Ostermaier2010} to search for real-world dynamic conditions such as \quote{finding the most quiet place in a city}. In their approach, probabilistic models are used to determine which actual sensors to contact for a particular query. Frank et al. study the use of a distributed query infrastructure composed of mobile nodes that can be used to search for the location of real-world objects~\cite{Frank2007,Frank2008}. A concept that inspired us to implement an application with RFID enabled mobile phones on top of the EPC network infrastructure as published in~\cite{Guinard2008} and described in \sectRef{epcFind}.

These engines and applications focus on leveraging the dynamic conditions of \sts{} which is a very promising approach to create real-world computational engines. Our target with the \findLayer{}, however, is slightly different. Indeed, we enable the search not for particular real-world situations but for services provided by \sts{} corresponding to user queries. This supports developers, tech-savvies and end-users in finding the services required to create composite applications such as \pMashups{}.

Haodong et al. took such an approach and propose Snoogle~\cite{HaodongWang2010}. This search engine can be used to find a particular mobile object or a list of objects that are likely to serve the requested service. It uses information retrieval techniques to maintain indexes of keywords corresponding to \sts{}. These indexes are managed by so called \important{Index Points} that are local to the \sts{} (e.g., one Index Point per room). On top of these local Index Points, a single mediator is maintaining an aggregate view of the whole network. A similar approach is taken by Yap et al. in MAX~\cite{Yap2005}. However, unlike in Snoogle where the \sts{} push information to the Index Point, in MAX metadata (keywords) are pulled from the infrastructure and the nodes upon queries. These approaches represent powerful real-world search engines but their integration to global networks such as the World Wide Web was not addressed.

Closer to our work, in a theoretical paper, Stirbu proposes leveraging the distributed infrastructure of \sts{} to achieve a discovery system on the Web~\cite{Stirbu2008}. The author considers the idea of devices registering themselves to a Registry Service through a simple HTTP \code{POST} call. However, the device has to post its full description to the Registry Service that publishes it in an Atom feed. This is a rather strong coupling between the device and the Registry. We avoid this by proposing an architecture inspired from Stirbu's proposal but rather consider the \sts{} as passive actors that just submit their root URIs either directly or through users. The actual semantic metadata extraction process is handled by the infrastructure. Just as search engines crawl pages of information without hard constraints on those pages, our LLDUs (with the help of a \transService{}) crawl the \sts{} to extract relevant metadata.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                While we clearly do not pretend offering a comprehensive way to describe and search for all types of \sts{} on the Web, our approach leverages the lightweight infrastructure put in place at the \devLayer{} of the \WoTA{} and extends it with LLDUs that are used to retrieve metadata and offer localized service lookup queries. Furthermore, thanks to the combination of RESTful Web APIs respecting the REST constraints and different implementations of the \stm{} model (e.g., microformats or RDFa\cite{Aguilar2010}), we have a flexible and rather loosely-coupled way of crawling metadata without strong requirements on the \sts{} themselves.


\subsection{\shareLayer{}}
In recent years, the world experiences a renewed trend towards sharing physical resources in all kinds of domains~\cite{Botsman2010}. More specifically, in the Internet of Things domain, data sharing was identified as one of the key enablers~\cite{Vazquez2008,Blackstock2011}. As a consequence several research platforms such as SenseWeb~\cite{Grosky2007,Luo2008}, the Global Sensor Networks (GSN)~\cite{Aberer2007}, the SOCRADES Integration Infrastructure~\cite{DeSouza2008} or SensorBase~\cite{Chen2007} appeared. These early approaches inspired research in the field but did not use Web standards which requires additional bridges to re-use the data they hold on the Web.

The recent trend to adopt Web technologies and in particular RESTful architectures has influenced platforms such as Pachube or Sensor.Network~\cite{Gupta2010} which propose a solution by providing a central platform for people to share their sensor data. However, these approaches are based on a centralized data repository to which the data is pushed and do not allow authorized and authenticated direct interaction with \sts{} as we enable it with the \sacLong{} architecture. More importantly, unlike \sac{}, these platforms are based on their own access control lists which are hard to scale, maintain and manage.

Vasquez~\cite{Vazquez2008} introduced the notion collaboration between social networks and smart objects. Furthermore, several research projects have been focusing on leveraging the value of social graphs from existing social networks to share \sts{}. In~\cite{Blackstock2011} Blackstock et al. provide a survey of Social Web of Things projects. Several projects explore the use of Twitter as a publishing and sharing mechanism for \sts{}~\citeweb{things-tweet}. As an example, the S-Sensors project~\cite{Baqer2009} specifically looks at the use of Twitter as a messaging and sharing mechanism for Wireless Sensor Networks. The SenseShare~\cite{Schmid2007} project allows users to share sensor data with their friends. It also allows owners to apply different filters to the data before sharing it. 

While SenseShare was a source of inspiration for the \sac{} architecture, it presents some shortcomings. Similarly to Pachube or Sensor.Network, SenseShare acts as a data store between the sensors and the clients. SenseShare and S-Sensors further allow sharing the data coming from sensors but do not support direct interactions with the sensors. As an example, one can't enable switching on/off devices by close relatives. Similarly, a Web-enabled Hi-Fi system couldn't enable songs to be played remotely through a RESTful interface which access is managed by the sharing system.

Furthermore, SenseShare or S-Sensors require the use of Facebook, respectively Twitter. Such a tight coupling with a single external service whose contract (API and allowed accesses) is subject to change over time, is problematic. It is also restrictive as it prevents from using a more adapted social network for a specific use-case. As an example, LinkedIn might be more adapted for a B2C (Business to Consumer) or B2B (Business to Business) sharing of \sts{}. This led us to the interoperability requirement of \sac{}, which supports different social networks, and enables users to control which one to use for each \st{}. 

Recent work, published after the \sac{} project~\cite{Guinard2010-sharing}, also leverages recent standards such as OAuth, OpenID and OpenSocial to offer an interoperable solution to real-world data sharing. The SENSE-ATION~\cite{Shirazi2010} project enables sharing sensory data coming from mobile phones. Its focus, however, is to offer this information to the developers of applications hosted on social networks (e.g., OpenSocial Gadgets). Similarly, Parimpu~\cite{Pintus2011} offers a platform inside which applications based on sensor streams can be created and shared with Twitter contacts.

\subsection{\compoLayer{}}
The idea of physical devices that can be composed together and with their environment to create new applications has been long dreamed of by pioneers such as Mark Weiser~\cite{Weiser1991} and often refined since then for instance in the vision of heterogeneous homes~\cite{Aipperspach2009}.

Key in these vision is the notion of end-users being able to create these simple composite applications on their own. Implementations of this vision appeared thanks the evolution of opportunistic programming in which developers have access to tool-chains and programming languages helping them to iterate more rapidly, creating small prototypes with a very limited amount of code~\cite{Brandt2009,Hartmann2008}. This evolution was further fostered by the developments of Web technologies and languages considered as relatively easy to use and develop upon~\cite{Roelands2011}. 

Following these developments, the idea of enabling opportunistic applications by mixing the physical world (i.e., \sts{}) and the Web appeared~\cite{Kindberg2002}. Later, these opportunistic applications were influenced by the concepts of Web 2.0 mashups studied for instance in~\cite{Yee2008,Yu2008a}, where end-users are empowered to create simple composite applications on the Web. Wilde proposed the notion of \important{\pMashups{}} as \quote{[...] new applications using this unified view of the Web of today and tomorrow’s Web of Things}. In~\cite{Guinard2009} we proposed an experimentation and implementation of \pMashups{} and refined the notion together with Trifa and Wilde in~\cite{Guinard2010-WoT}.

Furthermore, in~\cite{Roelands2011}, Roelands et al. discuss the notion of \quote{Do-it-Yourself} in the space of the Internet of Things. They define the concept of \quote{Smart Composables Internet of Things} and explain how physical mashups can contribute to end-user re-usability of \sts{}.

Several researchers explored ways of easily combining physical objects and Web technologies to create ad-hoc applications. Vermeulen et al. proposed to let users link physical object to composite services on the Web using RFID tags~\cite{Vermeulen2007}. Similarly, Vasquez and Lopez-de-Inpina explored several simple applications where end-users could combine physical devices with services on the Web~\cite{Vazquez2008}. 

Rather than considering single use-case, we propose an architecture that supports several types of mashups. In this space, researchers identified the mobile phone as being a key platform for \pMashups{}~\cite{Maximilien2008}, thanks to its ubiquitous Web access. Brodt and Nicklas~\cite{Brodt2008} present an architecture for creating mashups on mobile phones using JavaScript and HTML as well as a mashup server where wrappers for each service are implemented. Mikkonen et al. propose a mashup framework running on embedded devices~\cite{Mikkonen2010}. The architecture of these solutions targets the use of mobile devices as \sts{}, in our approach we would like to support other types of \sts{} and enable their dynamic discovery.

Several projects explore more generic solutions where different smart objects can be composed to create new applications. Vermeulen et al. propose the use of Semantic Web Technologies to enable for semi-automated mashups between the physical and digital world~\cite{Vermeulen2007a}. This approach is promising but taking an automated approach slightly differs from the level of flexibility envisioned in \pMashups{} were people can \important{re-wire} the physical world~\cite{Hartmann2008} themselves, using simple compositions and rules.

Carboni and Zanarini propose the concept of Hyperpipes inspired from the Unix pipes~\cite{Carboni2007}. Hyperpipes are defined using a relatively simple Domain Specific Language based on the concept of sink and source objects that can be connected together. As an example, hyperpipes can be used to redirect the screen output of a laptop to a board. The authors further create a mobile application from which the \sts{} can be piped together.

We take a similar approach by proposing an extended language set (DSL) for \pMashups{} offering more possibilities and slightly more complex mashups. Furthermore, rather than proposing a single mashup editor we build the framework as a service featuring a RESTful API that can be used to create and run \pMashups{} and \pMashup{} editors.


\section{Summary}
In this chapter, we presented our \WoTA{} and its four layers. Rather than being a strictly layered architecture we suggest it should be taken as a set of architectural guidelines that help facilitate, brick by brick, the integration of \sts{} into Web applications.

In the \devLayer{}, we propose to push the Internet and the Web down to the \sts{} themselves. We explain how a Resource Oriented architectural approach can be used to model the services \sts{} have to offer and provide them through a uniform API for the real-world based on REST.
Furthermore, we discuss the need for \sts{} to push events rather than being constantly polled and propose a solution based on the upcoming developments of the Web such as HTML5 WebSockets.

For devices that cannot connect to the Internet and offer their services through a Web server, we propose the concept of \sgs{} which act as reverse proxies that can be dynamically extended to support new kinds of \sts{} and proprietary or lower-level protocols. We also provide an evaluation of the differences in terms of performance between an end-to-end HTTP approach and a synchronization-based \sg{} mediated approach. With this, we illustrate how a \sg{} helps scaling deployments and applications.

In the \findLayer{} we propose a set of metadata that covers the most important data required to enable searching for \sts{} on the Web and to automate processes such as simple UI rendering or the automatic generating of mashup building-blocks for \sts{}. We implement this model by using microformats combined with the crawling of RESTful APIs. We also extend the network of Web-enabled \sts{} and \sg{} with the concept of Local Lookup and Discovery Units that enable the registration and indexing of \sts{}. Furthermore, they allow mashup developers and users to formulate several types of local and contextual queries that help them finding the right services offered by \sts{}.

In the \shareLayer{} we emphasize on the importance of having an authentication and sharing mechanism for \sts{}. Instead of creating anonymous access control lists we leverage social networks and create a proxy called \sacLong{} that bridges social networks and the \WoT{}, implementing a Social \WoTLong{} in which owners of \sts{} can share their devices with friends, colleagues or relatives. This proxy can be deployed at several places in the network and manages both the access to things and the authentication on social networks through their Web connectors.

In the \compoLayer{} we adapt an existing mashup framework to Web-enabled \sts{} and illustrate how this process is made straightforward thanks to the use of Web standards. We further introduce the \pMashupsFw{} that was specifically designed to manage the life-cycle of \pMashups{}.

Finally, we consider a WS-* alternative architecture. We analyze the body of research comparing WS-* and RESTful architecture for \sts{} and complement these evaluations by a qualitative evaluation describing the experience of developers implementing a prototype using both technologies. We conclude that WS-* services have advantages for applications requiring complex service contracts or with high security requirements. However, when considering ease of use, ease of learning, Web integration and fostering public innovation, the RESTful approach seems more adapted.

In the next two chapters, the presented architecture is applied and evaluated in two concrete domains, Wireless Sensor Networks and automatic identification networks.
