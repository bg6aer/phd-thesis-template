\section{\compoLayer{}}\label{physicalMashups}
\begin{center}
\includegraphics[width=0.7\linewidth]{figures/wot/compoLayer}
\end{center}
At large, the \WoTLong{} materializes into an open ecosystem of digitally augmented objects on top of which applications can be created using standard Web languages and tools. With the previous layers, we allowed developers to access and search for Web-enabled \sts{} and owners to have a simple and scalable mechanism to share them. Much is to gain from Web integration as it drastically eases the usually rather tedious development of applications on top of \sts{}.

In this last layer, we would like to push further the boundaries of the \WoT{} so that from getting close to developers, it also gets closer to end-users and enables them to create simple composite applications on top of \sts{}. Indeed, the previous layers also deliver more flexibility and customization possibilities for end-users. 

\subsection{Physical Mashups in the Web of Things}
In this section we look at the concepts of Web 2.0 Mashups and further define the notion of \pMashups{}. We then discuss the special requirements of the \WoTLong{} and propose a \pMashups{} architecture based on these requirements.

\subsubsection{Web 2.0 Mashups}
Web Mashups are defined as: \quote{Web applications generated by combining content, presentation, or application functionality from disparate Web sources. They aim at combining these sources to create useful new applications or services} by Yu et al.~\cite{Yu2008a}.

Yee~\cite{Yee2008} characterizes mashups along the combinations of three actions or patterns:
\begin{enumerate}
 \item Data is extracted from a source web site.
 \item The data is translated into a form meaningful to the destination web site.
 \item The repackaged data is sent to the destination site.
\end{enumerate}

Following this pattern, Housingmaps~\citeweb{housingmaps} is one of the most well-known Web mashups. It extracts the list of apartments, rooms or flats that are available for rent or sale on the Craigslist Web site~\citeweb{caigslist} and displays them on Google Maps~\citeweb{googlemaps} according to their location~\cite{Yee2008}. The result is a new service which helps people visually and geographically identifying real estate listings.

Mashup creators often also share their mashups on the Web (sometimes through directories such as the Programmable Web API directory~\citeweb{programmableweb}) and expose them through open APIs as well, making the ecosystem grow with each application and mashup.

The creation of composite applications is key in the idea of mashups. However, according to the literature~\cite{Yu2008a,Pautasso2008,Hartmann2008,Brandt2009}, there are several differences between Web mashups and traditional composite applications:
\begin{description}
  \item[Lightweightness and Simplicity] The technologies used for mashups mainly involve Web standards (e.g., HTML, HTTP, Atom, RSS, Microformats), scripting languages (e.g., JavaScript) and Web programming languages (e.g., PHP, Ruby, Python, etc.)~\cite{Yee2008,Yu2008a}. As a consequence mashups are rather lightweight applications that can be brought to several clients through Web (and mobile Web) browsers. 
 
  \item[Accessibility to a Larger Public] A direct consequence of the simplicity of mashups is their accessibility to a larger public than traditional composite applications. Manual mashups~\cite{Yu2008a}, i.e., mashups that are created without the use of dedicated tools are still mostly targeted towards (Web) developers. However, through the use of mashup editors, lightweight Web composition is brought closer to tech-savvies thanks to the use of visual metaphors and wizard assistants. 
 
  \item[Prototypical and Opportunistic Nature] Traditional composite applications in the enterprise software business are often achieved either using proprietary programming solutions or WS-* services with composition standards such as BPEL (Business Process Execution Language)~\cite{Hoyer2008,Pautasso2008}. On the contrary mashups are often used for more ad-hoc applications such as rapid prototypes or to create applications that fits the needs of individuals or a handful of people with more relaxed quality of service and security requirements~\cite{Pautasso2008,Brandt2009}. However, in the last few years, mashups have evolved to be also considered as a valid development technique for the world of enterprise applications~\cite{Hoyer2008}. 
\end{description}

\subsubsection{\pMashups{}}
We propose a unified view of the Web of today and tomorrow's Web of Things in applications called \important{\pMashups{}}~\cite{Wilde2007,Guinard2009-INSS,Guinard2010-WoT}. Tech-savvies, i.e., end-users at ease with new technologies, can create \pMashups{} by composing virtual and physical services. Following the trend of Web~2.0 participatory services and in particular Web mashups, users can create applications mixing real-world devices such as home appliances or sensors with virtual services on the Web. As an example, a Hi-Fi system could be connected to Facebook or Twitter in order to post the songs one listens to the most.

We distinguish three mashup development approaches for \pMashups{} and relate them to their main target groups:\begin{description}
 \item[\mashupLevelA{}] Introduced in~\cite{Yu2008a}, we refine this type of development in a \WoT{} context as: development of composite applications that involve \sts{} by means of Web technologies such as HTML, HTTP, Atom and JavaScript but without requiring the use of specific mashup tools. This type of development is meant to be undertaken by actual developers. However, thanks to the previously presented layers and approaches, \sts{} are brought to Web developers rather than embedded systems specialists~\cite{Mottola2011}. We used this type of development approach for instance to realize the \newterm{Energie Visible} mashup presented in \sectRef{evisibleUserInterface}.

 
 \item[\mashupLevelB{}] In this type of development a software framework, sometimes called \important{portal} communicates with the \sts{} and makes their data available through a black-board~\cite{Yu2008a} approach where the data are constantly written to variables in memory. The developers then simply have to create widgets (or portlets) that read and write to these variables. These widgets are usually written using a combination of HTML and JavaScript code. Since it fully abstracts the communication with \sts{} this model is a \important{higher abstraction level}. A direct consequence of this development model is that domain experts (e.g., experts in supply chain management) with IT skills can build composite applications for their domain without having to learn the subtleties of embedded systems. This development approach was used to create the \newterm{EPC Dashboard Mashup} presented in \sectRef{EPCDashboardMashup}.

 \item[\mashupLevelC{}] This development approach enables end-users to create their own composite applications. In the case of Web 2.0 Mashups this type of application is usually developed through a mashup editor, e.g., Yahoo Pipes~\citeweb{pipes}, which is a Web platform that enables people to visually create simple rules to compose Web sites and data sources. A similar approach can be applied to empower users to create small applications tailored to their needs on top of their \sts{}. In the next section we discuss the specific requirements of Physical Mashup Editors and describe the architecture of a platform for building these editors. 
\end{description}

\subsection{From Web 2.0 Mashups Editors to Physical Mashup Editors}
While Web 2.0 Mashup techniques and tools can be largely re-used for the \WoTLong{}, the physical world has some special constraints that need to be addressed when designing \pMashups{} editors. We deduce these constraints based on a case-study in which we adapted an existing Web 2.0 Mashup Editor to be used as a \pMashups{} editor. Then, for the identified constraints we propose a number of requirements~\cite{Guinard2010-mashup-home}.

\subsection{Adapting a Web 2.0 Mashup Editor to the \WoTLong}\label{clickscript}
\begin{figure}
\imgLine{wot/cs-light-sensor}
\caption{A \pMashup{} with a modified version of the Clickscript Mashup editor. The mashup turns a lamp on whenever the light level observed by a real-world sensor is above a threshold.}
\label{fig:cs-light-sensor}
\end{figure}
To better understand the requirements of a \pMashups{} editor, we adapted an existing Web 2.0 Mashup Editor to include building-blocks featuring access to \sts{}. Our case-study is based on the Clickscript project~\cite{Naef2009}. Clickscript if a Web platform~\citeweb{clickscript} written in JavaScript and HTML on top of two popular JavaScript libraries (Dojo~\citeweb{dojo} and JQuery~\citeweb{jquery}). Clickscript allows people to visually create Web 2.0 Mashups by connecting building-blocks of resources (e.g., Web pages, strings, etc.) and operations (e.g., greater than, if/then, loops, etc.).

We decided to use Clickscript for two main reasons: First, since the editor was created only with client-side Web technologies its deployment and extension is very straightforward and can illustrate well the integration of \sts{} to pure Web scripting languages. Then, Clickscript was created with the aim of teaching young children the basics of programming. As a consequence, its usage is very simple and accessible even to non-technical people~\cite{Naef2009}.

Since Clickscript is written in JavaScript and running in the browser, it cannot use resources based on low-level protocols such as Bluetooth or Zigbee. However, it offers full HTTP support and hence can easily access RESTful services. As \WoT{} devices implemented using the architecture described in the \devLayer{}, \findLayer{} and \shareLayer{} are fully accessible through a RESTful Web API, it is straightforward to create Clickscript building-blocks supporting \sts{}. 

We used this approach to create Clickscript building-blocks for all the devices we present in the case-studies of this thesis (see \chapterRef{wsn} and \chapterRef{autoid}). The generic JavaScript code required to integrate a \st{} as a ClickScript building-block is shown in \lstRef{csBuildingBlock}. This concise snippet of code is a template of all that is required to integrate any \sts{} that implements, at least, the \devLayer{} of the \WoTA{}.

The result of this script is a new ClickScript building-block that can be used by end-users to create simple \pMashups{}. As an example, the mashup shown in \chapterRef{wsn} (\figRef{clickscriptRule}) gets the light level in a room by \code{GET}ting the light resource of a sensor. If it is bigger than a given threshold, it turns the light off by sending it a \code{PUT} request.

\lstinputlisting[caption=Generic JavaScript code required to integrate a new smart thing to the Clickscript mashup editor as a Clickscript building-block, label=lst:csBuildingBlock, breaklines, numbers=left, numberstyle=\tiny, xleftmargin=0.8cm, basicstyle=\small\ttfamily, backgroundcolor=\color{gray}, captionpos=b]{code/clickScriptBuildingBlock.js}


This readily illustrates the simplicity of adapting an existing mashup editor to \WoT{} devices thanks to their Web integration. However, it also illustrates the shortcomings of the approach. First, while creating mashups can be done by end-users, creating new building-blocks is still only accessible to the community of Web developers. To prevent this, a \sts{} discovery mechanism should be implemented in order to automate the creation of the corresponding building-blocks.

Second, for the mashup shown in \figRef{clickscriptRule}, the mashup editor has to constantly pull the temperature from the device which is sub-optimal. Hence the need to support push mechanisms as described in \sectRef{push}. This lack of push support is a common characteristic of client-side mashup editors since an HTTP Callback (Web Hook) approach is not possible in this case. However, we adapted Clickscript to support HTML5 WebSockets. 

The original version of Clickscript offers two ways of executing mashups: First, the end-user can manually start the mashup by pressing a \code{Run} button triggering the execution process. Alternatively, he can use a \code{Repeated-Run} button which runs the mashup in an infinite loop. We added an asynchronous, push-based execution model. The extended execution method using WebSockets is shown in \figRef{seqMashup}. When using this option, the user is prompted for the URI of an HTML5 WebSocket enabled server, e.g., an instance of the \tpusher{} service running on a \sg{} (see \sectRef{real-time-and-tpusher}). This URI is used to register the Clickscript client to the WebSocket server.

Each incoming HTML5 WebSocket message triggers the execution process. Furthermore, following a black-board approach~\cite{Yu2008a}, the payload of each incoming HTML5 message is extracted and written to a variable accessible to all building-blocks. 
\begin{figure}
\centering
\imgLine{wot/sequence-push-clickscript}
\caption{Sequence diagram of a typical Web-push triggered execution in the extended version of the Clickscript mashup editor. The editor subscribes to a WebSocket (or Comet) topic and writes the incoming messages to a black-board variable which is then read by building-blocks.}
\label{fig:seqMashup}
\end{figure}
A concrete \pMashups{} prototype based on this Web-push enabled version of Clickscript is described in \chapterRef{autoid}, \sectRef{boxesAndPointers}.

\subsection{Requirements for Physical Mashup Editors}
As a result of the prototype built on top of the Clickscript Web 2.0 Mashup editor, we propose a number of requirements for editors of \pMashups{}~\cite{Guinard2010-mashup-home}:
\begin{description} 
  \item[Support for event-based mashups] The current Web, and thus the vast majority of Web 2.0 mashup editors, are based on the concept of clients pulling information from servers~\cite{Yu2008a}. Several studies~\cite{Duquennoy2009a,Trifa2010} have shown that while this model matches the requirements for controlling \sts{}, it is inefficient for real-world monitoring applications. Hence, the need for \pMashups{} editors to offer core support for event-based interactions, where parts of the workflows of mashups can be triggered based on events pushed from \sts{} to the editors using Web push mechanisms.

  \item[Support for dynamic building-blocks] Manually creating building-blocks for each thing does not scale with the heterogeneity of objects in the physical world. Thus, the need for the mashup editors to support partially automated integration through service discovery techniques leveraging the \findLayer{}.

  \item[Support for non-desktop platforms] Web 2.0 mashup editors are for the large part meant to run in Web browsers of desktop computers. However, in the case of the \WoTLong, the in situ development of \pMashups{} e.g., on mobile phones or tablets should be fostered as virtual interactions with the physical world can really benefit from occurring beyond the desktop metaphor~\cite{Brodt2008,Ullmer1998}.

  \item[Support application specific editors] Due to the heterogeneity of use-cases in the \WoTLong, a \quote{one-size-fits-all} mashup editor is very unlikely to use adapted metaphors and tools for a particular domain. Hence, rather than creating a mashup editor, the architecture should be a mashup platform exposing an API that can be used to develop specific mashup editors (e.g., a mashup editor for supply chain related or home automation use-cases). This also lets users create their mashups locally, e.g., on a mobile phone, and export them to a more robust framework for execution.
\end{description}

%\todo{2: Analyze the existing mashup pforms against these requirements}

\subsection{A Platform for Physical Mashups Editors}\label{mashupFw}
\begin{figure}
\imgMedium{wot/pmashupFwOverview}
\caption{Overview of the \pMashupsFw{}. The framework is the mediator between \sts{}, virtual services and clients (domain-specific mashup editors).}
\label{fig:mashupFwork}
\end{figure}
The goal of the \pMashupsFw{}~\cite{Aguilar2010,Guinard2010-mashup-home,Kovatsch2010} is to offer a platform that fulfills the requirements discussed before. Rather than providing a generic mashup editor, the \pMashupsFw{} is a mashup engine, i.e., a Web service capable of running mashups~\cite{Yu2008a}.

As shown in \figRef{mashupFwork}, the framework is a composition environment between Web-enabled \sts{} and virtual services such as messaging or visualization services. It features a RESTful Web API using which actual mashup editors can be built. These editors use the framework for managing the life-cycles of mashups, from the definition of mashups to the discovery of virtual and smart things' services and the actual execution of the mashups.

The \pMashupsFw{} is not a mashup editor itself. Indeed, the idea is for the framework to support the creation of domain-domain specific mashup editors. For instance, in \sectRef{wsn-mashup-editor} we build a mobile mashup editor dedicated to create simple applications that optimize the energy consumption of household appliances. The mobile application uses the \pMashupsFw{} RESTful Web API to create and run the mashups in the framework's engine.

\subsection{System Architecture}
In this section we further describe the functionality of the \pMashupsFw{} by focusing on the most important components of the architecture as shown in \figRef{mashupFworkCompo}.

\subsubsection{Discovery Component}
The \code{DiscoveryComponent} implements the requirement for \important{supporting dynamic mashup building-blocks}. It is an implementation of the \transService{} described in \sectRef{translationService} that uses semantic annotations crawled from the \sts{} HTML representation to generate an internal representation of the Smart Thing Description model.

Mashup editors can then retrieve a serialized version of this description (in the form of a WADL file) that they can use to dynamically generate relevant user interfaces for the building-blocks corresponding to the newly discovered \st{}.

\subsubsection{Workflow Engine}
Core to the \pMashupsFw{} is a mashup engine. This engine is responsible for the life-cycle of \pMashupsFw{}. It compiles the mashups into a runnable workflow composed of several building-blocks and runs it.

Rather than creating an engine from scratch, the \pMashupsFw{} is based on the Ruote workflow engine~\citeweb{ruote}. Ruote is an open-source lightweight workflow engine that is well suited to manage workflows that call several services on the Web, especially when these services are HTTP-based and RESTful.

\paragraph{A Domain Specific Language for Workflows}\label{mashupLanguage}
To create workflows, Ruote provides a Domain Specific Language~\citeweb{ruote} that we reuse in the workflow engine of the \pMashupsFw{}. We briefly describe the most important language construct of the workflow DSL:

\begin{description} 
  \item[Expression] A Ruote-based workflow describes a process composed of \code{Expression}s. Each step in the process is represented as an \code{Expression}.
  
  \item[Workitem] \code{Expression}s communicate with each other based on a message passing mechanism. The message is initialized at the beginning of the process and modified by each \code{Expression}. In the Ruote DSL, such a message is called \code{Workitem}.

  \item[Participant] are the most important form of \code{Expression}s, they perform the business logic of the workflow at each step of the process. The engine manages the orchestration among \code{Participant}s by sending and receiving the \code{Workitem}s. Ruote provides a large set of predefined \code{Participant}s but new ones can be added very easily by implementing two methods: \code{initialize} and \code{consume}. The former is called whenever a participants is added to a workflow whereas the latter is called when a \code{Workitem} is applied by the engine to the \code{Participant}.
\end{description}

Further constructs of the workflow DSL are common language elements such as process-definition constructs, sequences, conditional expressions, loops, subprocesses and listeners. \lstRef{workflow} presents a simple process (i.e., workflow) definition in XML. Ruote supports such definitions in XML, Ruby or JSON.
\lstinputlisting[caption=A typical process (workflow) definition using an XML representation of the Ruote Workflow DSL language., label=lst:workflow, breaklines, numbers=left, numberstyle=\tiny, language={Java}, xleftmargin=0.8cm, basicstyle=\small\ttfamily, backgroundcolor=\color{gray}, captionpos=b]{code/workflow-def.xml}


\subsubsection{\pMashups{} Building-Blocks Library}\label{blocks}
\begin{figure}
\imgMedium{wot/pmashupFw}
\caption{Most important components of the \pMashupsFw{}. The Workflow Engine manages the life-cycle of mashups and runs them as workflows. The Discovery Component supports the dynamic integration of new metadata-annotated \sts{}. The Building-Blocks Library provides the building-blocks for creating \pMashups{} and the Repositories are used to store mashups, building-blocks and data coming from \sts{}.}
\label{fig:mashupFworkCompo}
\end{figure}
To adapt it to \pMashups{}, we extend the Ruote DSL with \WoT{} specific building-blocks. These blocks complement the existing DSL in the form of \code{Participants} constructs. 

The interesting aspect is that rather than specifying them using a programming language, these blocks can be specified through the RESTful API of the \pMashupsFw{} using either XML or JSON representations sent as payloads of HTTP messages. As a consequence, clients (i.e., mashup editors) can build mashups online, block by block using the framework API.

As shown in \figRef{mashupFworkCompo}, we created three types of building-blocks, \newterm{source}, \newterm{processing} and \newterm{target} blocks. We describe each of these tasks below.

\paragraph{Source Blocks}
These building-blocks correspond to the inputs of the mashups, i.e., \sts{} or virtual services on the Web. Four types of source blocks are defined and implemented:

\begin{description}
 \item[REST Blocks] Are the most important building-blocks from a \WoT{} perspective. They encapsulate HTTP interactions with resources. They can be used to add \sts{}, that were previously discovered by the \code{DiscoveryComponent}, to the workflows. Similarly, they can be used to interact with RESTful virtual services on the Web. \lstRef{restBB} shows an example of \code{RESTBlock} used to retrieve the temperature value of a Web-enabled sensor node. 

 \item[SOAP Blocks] In order to support WS-* services, a SOAP building-block is implemented. Since the workflow engine takes care of the invocation, this component is especially interesting in the case of mashup editors running on resource-constrained devices such as mobile phones as these might not be able to invoke WS-* services directly. 

 \item[Repository Blocks] In more complex \pMashups, a solution to persist data is often required. As an example reacting on the power consumption of a particular device might require to store the measurements over time and perform analysis on aggregated data. For this purpose, a \code{RepositoryBlock} allows to create persistent collections of data that can be queried later using processing blocks.

 \item[Subscription Blocks] As we have seen before, \sts{} might provide their functionality asynchronously, pushing it back to the clients whenever it becomes relevant, hence the need to support \important{event-based mashups}. The \code{SubscriptionBlock}s implement this requirement using an HTTP Callback approach (see \sectRef{push}). These blocks can be used to subscribe to events and clients can specify which building-block of the workflow will be the recipient of incoming events. Internally, a \code{SubscriptionBlock} generates a callback URI containing the name of the recipient block that will be caught by the Mashup Entry Point component and routed to the correct block.
 \end{description}

\lstinputlisting[caption=XML definition of a REST building-block retrieving the temperature value from a \WoT{} sensor node., label=lst:restBB, breaklines, numbers=left, numberstyle=\tiny, language={XML}, xleftmargin=0.8cm, basicstyle=\small\ttfamily, backgroundcolor=\color{gray}, captionpos=b]{code/restBB.xml}

\paragraph{Processing Blocks}
As shown in \figRef{mashupFworkCompo}, Processing Blocks represent the logic (e.g., mathematical operations, filtering, querying, etc.) between inputs and outputs. As defined by Yee~\cite{Yee2008} a common operation in mashups is to translate the data into a form meaningful to the destination service. Part of the translation process is the extraction of the relevant data. \code{QueryBlock}s offer a simple language construct to perform the most frequent data extraction operations.

The basic input of a \code{QueryBlock} is a data source or a set of data sources. Data sources can be either XML or JSON representations specified by URIs pointing either to actual resources on the Web or to internal resources stored using a \code{RepositoryBlock}.

A \code{QueryBlock} can be configured by means of several parameters:
  \begin{itemize}
    \item \code{Select} allows to configure which attributes should be extracted as outputs of the query. This parameter is functionally similar to a SQL \code{select}.
    \item \code{First} allows limiting the number of returned attributes (e.g., the first 10 attributes).
    \item \code{Filter} allows to do some simple filtering on the data. It supports logical operators, comparison operators as well as simple regular expressions.
    \item \code{Sort} is similar to the SQL \code{order by} operator.
    \item \code{GroupBy} allows to get a summarized view of the queried data. Similarly to the SQL \code{group by} statement it aggregates the data. The supported aggregation functions are max, min, sum, count and average.
  \end{itemize}

\lstRef{queryBB} provides an example of the definition of a \code{QueryBlock}. The output of the block is a JSON document that contains the values of the last trace recorded by a GPS sensor (e.g., a mobile phone).

\lstinputlisting[caption={XML definition of a Query building-block. This block extracts, from a repository, the latest location sent by a GPS sensor.}, label=lst:queryBB, breaklines, numbers=left, numberstyle=\tiny, language={XML}, xleftmargin=0.8cm, basicstyle=\small\ttfamily, backgroundcolor=\color{gray}, captionpos=b]{code/queryBB.xml}


\paragraph{Target Blocks}
As shown in \figRef{mashupFworkCompo}, \code{TargetBlock}s are the outputs of compositions. They represent services that can be actuated as a result of processing the input data. Four types of \code{TargetBlock}s are supported by the framework:
\begin{description}
 \item[AtomPub Blocks] These components supports publishing JSON, XML or HTML data to any server complying with the AtomPub protocol described in \sectRef{push}. 

 \item[Twitter Blocks] These components encapsulate the Twitter API, letting data coming from \sts{} being pushed to Twitter.

 \item[XMPP Blocks] These components support the XMPP messaging protocol used in several Web messaging clients such as Google Chat and sometimes used to provide real-time data from \sts{}~\cite{Hornsby2010,Hornsby2009}.

 \item[Visualization Blocks] These blocks offer a set of visualization methods such as graphs that are implemented using the Google Visualization API~\citeweb{googlevisu}.
 \end{description}

Additionally, the \code{RESTBlock}s and \code{RepositoryBlock}s can be used as \code{TargetBlock}s as well. \code{RESTBlock}s enable, for instance, \sts{} to \sts{} communication and actuation through the \pMashupsFw{}. \code{RepositoryBlock}s, allows to use the framework as a database for \sts{}, where the real-world data can be preprocessed using \code{QueryBlock}s before storage.

\subsubsection{Repositories}
The \pMashupsFw{} offers two repositories. The Collection Repository is used by \code{RepositoryBlock}s to store JSON or XML data.
The Resource Repository mainly provides a persistent storage for mashups as well as extracted instances of the Smart Things Description model. Through this repository parts of or complete workflows can be referenced and used in other mashups, allowing for a reuse and sharing mechanism.

\subsubsection{RESTful API}
\begin{figure}
\imgLine{wot/mashup-fw-api}
\caption{Tree-representation of the RESTful API of the \pMashupsFw{}.}
\label{fig:mashupFworkAPI}
\end{figure}
As with every component of the \WoTA{}, the \pMashupsFw{} is based on a RESTful architecture and features a RESTful API as shown in \figRef{mashupFworkAPI}. Mashup editors and other clients can use it to build the mashups using an XML or JSON representation of the building-blocks. Furthermore, the API allows client applications to retrieve existing mashups and manage running instances.

The API is centered around the notion of a \code{user} where mashup definitions, discovered \sts{} and collections are associated with a specific user of the framework but can be shared amongst users.

\subsection{Discussion and Summary}
In this chapter we introduced the idea of \pMashups{}. We defined three categories of development approaches for \pMashups{}: First, \newterm{\mashupLevelA{}} which helps developers building upon \sts{} by streamlining the development process to simple Web development. In \sectRef{evisibleUserInterface} we demonstrate how this development approach made it easy to realize the \newterm{Energie Visible} mashup for energy-awareness. Similarly, in \sectRef{epcFind} we illustrate how it made possible to create the EPCFind prototype that leverages real-world RFID data to track and trace someone's belongings. Furthermore, with the \newterm{Ambient Meter} prototype presented in \sectRef{AmbientMeter}, we illustrate how the approach can also help \sts{} to \sts{} communication.

Then, with the \newterm{\mashupLevelB{}} the actual communication with \sts{} is transparent to the developer who simply has to use the incoming data (in a black-board approach) to create new applications encapsulated in JavaScript and HTML Widgets. We will demonstrate this development approach with the \newterm{EPC Dashboard Mashup} presented in \sectRef{EPCDashboardMashup}.

Finally, with the \newterm{\mashupLevelC{}} we explain how visual metaphors and simple editors can be used to enable end-users to create simple compositions. We illustrate this a straightforward adaptation of an existing mashup editor to \WoT{} devices. We further introduce the \pMashupsFw{} architecture that allows to build domain and device specific \pMashups{} editors and run the created mashups in the cloud. In \sectRef{energyMashupEditor} we propose a mashup editor that can be used to create simple applications on top of Web-enabled home appliances in order to make homes more energy aware and efficient.